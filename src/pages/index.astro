---
import BaseLayout from '@layouts/BaseLayout.astro';
import Hero from '@components/Hero.astro';
import Projects from '@components/Projects.astro';
import Timeline from '@components/Timeline.astro';
import ContactCard from '@components/ContactCard.astro';
---

<BaseLayout
  title="Nguyễn Hoàng Tín | Portfolio"
  description="Backend/Fullstack Developer"
>
  <div id="fullpage">
    <!-- Section 1: Hero -->
    <div id="home" class="section active" data-anchor="home">
      <Hero />
    </div>

    <!-- Section 2: Projects -->
    <div id="du-an" class="section next" data-anchor="du-an">
      <Projects />
    </div>

    <!-- Section 3: Timeline -->
    <div id="kinh-nghiem" class="section next" data-anchor="kinh-nghiem">
      <Timeline />
    </div>

    <!-- Section 4: Contact -->
    <div id="lien-he" class="section next" data-anchor="lien-he">
      <ContactCard />
    </div>
  </div>

  <!-- Load script từ public folder - chỉ load trên desktop -->
  <script is:inline>
    const MOBILE_BREAKPOINT = 768;
    
    // Check if mobile
    function isMobile() {
      return window.innerWidth < MOBILE_BREAKPOINT;
    }

    // Options cấu hình
    const initOptions = {
      anchors: ['home', 'du-an', 'kinh-nghiem', 'lien-he'],
      navigation: true,
      scrollingSpeed: 800,
      loopBottom: true
    };

    const anchors = ['home', 'du-an', 'kinh-nghiem', 'lien-he'];

    // Store scroll handler reference to prevent accumulation
    let mobileScrollHandler = null;

    // Setup mobile layout (normal scroll)
    function setupMobileLayout() {
      const fullpage = document.getElementById('fullpage');
      if (!fullpage) return;

      // Add mobile class to body for CSS
      document.body.classList.add('mobile-layout');
      document.documentElement.classList.add('mobile-layout');


      // Disable any fullpage.js event listeners
      if (window.vanillaFullpage) {
        try {
          if (window.vanillaFullpage.destroy) {
            window.vanillaFullpage.destroy();
          }
        } catch (e) {
          console.warn('Error destroying fullpage:', e);
        }
        window.vanillaFullpage = null;
      }

      // Remove fullpage classes that might interfere
      fullpage.classList.remove('fp-enabled', 'fp-vertical', 'fp-responsive');
      
      // Reset fullpage container styles
      fullpage.style.cssText = 'position: static !important; height: auto !important; overflow: visible !important; transform: none !important;';

      // Show all sections
      const sections = fullpage.querySelectorAll('.section');
      sections.forEach((section) => {
        section.style.cssText = 'position: relative !important; height: auto !important; min-height: auto !important; opacity: 1 !important; visibility: visible !important; display: flex !important; pointer-events: auto !important; transform: none !important; transition: none !important; overflow: visible !important; top: auto !important; left: auto !important; margin: 0 !important; padding: 0 !important;';
        section.classList.remove('active', 'next', 'prev', 'fp-completely');
      });

      // Setup native smooth scroll for hash links (only if not already set up)
      if (!document.body.hasAttribute('data-mobile-links-setup')) {
        const anchorLinks = document.querySelectorAll('a[href^="#"]');
        anchorLinks.forEach((link) => {
          // Skip if listener already attached
          if (link.hasAttribute('data-mobile-link-handled')) return;
          link.setAttribute('data-mobile-link-handled', 'true');
          link.addEventListener('click', (e) => {
            const href = link.getAttribute('href') || '';
            const target = href.replace('#', '');
            if (anchors.includes(target)) {
              const targetElement = document.getElementById(target);
              if (targetElement) {
                e.preventDefault();
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Update URL hash
                window.history.pushState(null, '', href);
                // Update sidebar active state
                updateSidebarActive(target);
              }
            }
          });
        });
        document.body.setAttribute('data-mobile-links-setup', 'true');
      }

      // Setup sidebar navigation for mobile (only if not already set up)
      const sidebarItems = document.querySelectorAll('.sidebar-list li');
      sidebarItems.forEach((item) => {
        const button = item.querySelector('button');
        const anchor = item.getAttribute('data-menuanchor');
        if (button && anchor) {
          // Skip if listener already attached
          if (button.hasAttribute('data-mobile-sidebar-handled')) return;
          button.setAttribute('data-mobile-sidebar-handled', 'true');
          button.addEventListener('click', (e) => {
            e.preventDefault();
            const targetElement = document.getElementById(anchor);
            if (targetElement) {
              targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
              window.history.pushState(null, '', `#${anchor}`);
              updateSidebarActive(anchor);
            }
          });
        }
      });


      // Clone sidebar-nav to sidebar-nav-mobile
      const sidebarNav = document.querySelector('.sidebar-nav');
      const sidebarNavMobile = document.querySelector('.sidebar-nav-mobile');
      if (sidebarNav && sidebarNavMobile && sidebarNavMobile.children.length === 0) {
        sidebarNavMobile.innerHTML = sidebarNav.innerHTML;
        
        // Fix duplicate ID issues - change mobile element IDs
        const clonedLangSwitcher = sidebarNavMobile.querySelector('#lang-switcher');
        if (clonedLangSwitcher) {
          clonedLangSwitcher.id = 'lang-switcher-mobile';
        }
        
        const clonedSidebar = sidebarNavMobile.querySelector('#sidebar');
        if (clonedSidebar) {
          clonedSidebar.id = 'sidebar-mobile';
        }
        
        // Re-attach event listeners for cloned sidebar items (only once)
        const clonedSidebarItems = sidebarNavMobile.querySelectorAll('.sidebar-list li');
        clonedSidebarItems.forEach((item) => {
          const button = item.querySelector('button');
          const anchor = item.getAttribute('data-menuanchor');
          if (button && anchor) {
            // Skip if listener already attached
            if (button.hasAttribute('data-mobile-cloned-handled')) return;
            button.setAttribute('data-mobile-cloned-handled', 'true');
            button.addEventListener('click', (e) => {
              e.preventDefault();
              const targetElement = document.getElementById(anchor);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                window.history.pushState(null, '', `#${anchor}`);
                updateSidebarActive(anchor);
              }
            });
          }
        });

        // Re-attach lang-switcher click handler for mobile
        // Re-query using the new ID to ensure we have a fresh, valid reference
        const mobileLangSwitcher = sidebarNavMobile.querySelector('#lang-switcher-mobile');
        if (mobileLangSwitcher && !mobileLangSwitcher.hasAttribute('data-mobile-lang-handled')) {
          mobileLangSwitcher.setAttribute('data-mobile-lang-handled', 'true');
          mobileLangSwitcher.addEventListener('click', function(e) {
            let target = e.target;
            while (target && target !== mobileLangSwitcher) {
              if (target.classList && target.classList.contains('lang-option')) {
                const lang = target.dataset.lang;
                if (lang === 'vi' || lang === 'en') {
                  e.preventDefault();
                  e.stopPropagation();
                  localStorage.setItem('lang', lang);
                  const event = new CustomEvent('langchange', { 
                    detail: { lang: lang },
                    bubbles: true,
                    cancelable: true
                  });
                  window.dispatchEvent(event);
                  return;
                }
              }
              target = target.parentElement;
            }
          });
        }

        // Sync active state after cloning
        const hash = window.location.hash.replace('#', '');
        const currentAnchor = hash && anchors.includes(hash) ? hash : 'home';
        updateSidebarActive(currentAnchor);
        
        // Set initial active state for mobile language switcher
        if (typeof window.getCurrentLang === 'function' && typeof window.setActiveLang === 'function') {
          const currentLang = window.getCurrentLang();
          window.setActiveLang(currentLang);
        }
      }

      // Update active state on scroll (for mobile)
      // Remove existing scroll listener if it exists to prevent accumulation
      if (mobileScrollHandler) {
        window.removeEventListener('scroll', mobileScrollHandler, { passive: true });
        mobileScrollHandler = null;
      }

      let scrollTimeout;
      mobileScrollHandler = function handleScroll() {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          const sections = document.querySelectorAll('.section');
          let currentSection = '';
          let minDistance = Infinity;
          
          // Find the section that is most visible in viewport
          sections.forEach((section) => {
            const rect = section.getBoundingClientRect();
            const sectionId = section.id;
            
            if (anchors.includes(sectionId)) {
              // Calculate how much of the section is visible
              const visibleTop = Math.max(0, rect.top);
              const visibleBottom = Math.min(window.innerHeight, rect.bottom);
              const visibleHeight = Math.max(0, visibleBottom - visibleTop);
              
              // Prefer section that is closer to top of viewport and has significant visibility
              if (visibleHeight > window.innerHeight * 0.3) {
                const distanceFromTop = Math.abs(rect.top);
                if (distanceFromTop < minDistance) {
                  minDistance = distanceFromTop;
                  currentSection = sectionId;
                }
              }
            }
          });
          
          // Fallback: if no section is significantly visible, use the one closest to top
          if (!currentSection) {
            sections.forEach((section) => {
              const rect = section.getBoundingClientRect();
              const sectionId = section.id;
              if (anchors.includes(sectionId) && rect.top >= 0 && rect.top < window.innerHeight) {
                const distance = rect.top;
                if (distance < minDistance) {
                  minDistance = distance;
                  currentSection = sectionId;
                }
              }
            });
          }
          
          if (currentSection && anchors.includes(currentSection)) {
            updateSidebarActive(currentSection);
          }
        }, 150);
      };
      window.addEventListener('scroll', mobileScrollHandler, { passive: true });

      // Handle hash on page load
      const hash = window.location.hash.replace('#', '');
      if (hash && anchors.includes(hash)) {
        setTimeout(() => {
          const targetElement = document.getElementById(hash);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      }

      // Initialize fade-in animations for mobile
      setTimeout(() => {
        initSlideInAnimations();
      }, 300);
    }

    // Destroy mobile layout (cleanup)
    function destroyMobileLayout() {
      document.body.classList.remove('mobile-layout');
      document.documentElement.classList.remove('mobile-layout');
      const sections = document.querySelectorAll('.section');
      sections.forEach((section) => {
        section.style.cssText = '';
      });
      
      // Remove scroll listener to prevent memory leaks
      if (mobileScrollHandler) {
        window.removeEventListener('scroll', mobileScrollHandler, { passive: true });
        mobileScrollHandler = null;
      }
      
      // Note: We keep data attributes to prevent re-attaching listeners if switching back to mobile
      // The listeners will still work, and the attributes prevent accumulation
    }

    // Khởi tạo VanillaFullpage khi DOM ready và script đã load
    function initFullpage() {
      // Check if mobile - don't initialize fullpagejs on mobile
      if (isMobile()) {
        setupMobileLayout();
        return;
      }

      // Kiểm tra xem class đã được load chưa
      if (typeof VanillaFullpage === 'undefined') {
        // Nếu chưa load, thử lại sau 100ms
        setTimeout(initFullpage, 100);
        return;
      }

      try {
        // Khởi tạo VanillaFullpage
        window.vanillaFullpage = new VanillaFullpage('#fullpage', initOptions);

        // Gắn handler cho các anchor CTA để cuộn đúng section
        const anchorLinks = document.querySelectorAll('a[href^="#"]');
        anchorLinks.forEach((link) => {
          link.addEventListener('click', (e) => {
            const href = link.getAttribute('href') || '';
            const target = href.replace('#', '');
            const idx = anchors.indexOf(target);
            if (idx !== -1 && window.vanillaFullpage) {
              e.preventDefault();
              window.vanillaFullpage.goToSection(idx);
              // Update active state
              updateSidebarActive(target);
            }
          });
        });

        // Handle sidebar navigation clicks
        const sidebarItems = document.querySelectorAll('.sidebar-list li');
        sidebarItems.forEach((item) => {
          const button = item.querySelector('button');
          const anchor = item.getAttribute('data-menuanchor');
          if (button && anchor) {
            button.addEventListener('click', (e) => {
              e.preventDefault();
              const idx = anchors.indexOf(anchor);
              if (idx !== -1 && window.vanillaFullpage) {
                window.vanillaFullpage.goToSection(idx);
                // Update active state immediately
                updateSidebarActive(anchor);
              }
            });
          }
        });

        // Function to check and update active section
        function checkActiveSection() {
          const sections = document.querySelectorAll('.section');
          sections.forEach((section, index) => {
            if (section.classList.contains('active')) {
              const anchor = anchors[index];
              if (anchor) {
                updateSidebarActive(anchor);
              }
            }
          });
        }

        // Update active state on section change using MutationObserver
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              checkActiveSection();
            }
          });
        });

        // Observe all sections for class changes
        const sections = document.querySelectorAll('.section');
        sections.forEach((section) => {
          observer.observe(section, {
            attributes: true,
            attributeFilter: ['class']
          });
        });

        // Also check periodically as fallback
        setInterval(checkActiveSection, 500);

        // Initial check
        setTimeout(checkActiveSection, 200);

        // Initialize fade-in animations for desktop
        // Trigger animations when section becomes active (user scrolls to it)
        function triggerActiveSectionAnimation() {
          const activeSection = document.querySelector('.section.active');
          if (activeSection) {
            const slideElement = activeSection.querySelector('[data-slide-in]');
            if (slideElement && !slideElement.classList.contains('slide-in-visible')) {
              slideElement.classList.add('slide-in-visible');
            }
            
            // Trigger fade-in items in active section (only when section becomes active, not on initial load)
            const fadeItems = activeSection.querySelectorAll('.fade-in-item');
            fadeItems.forEach((item) => {
              if (!item.classList.contains('fade-in-visible')) {
                const delay = parseInt(item.getAttribute('data-fade-delay') || '0');
                setTimeout(() => {
                  item.classList.add('fade-in-visible');
                }, delay + 200);
              }
            });
          }
        }

        // Initialize animations - but don't trigger for initial section
        initSlideInAnimations();

        // Track if this is the first time (initial load)
        let isInitialLoad = true;

        // Trigger animation only when section changes (not on initial load)
        const sectionObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              // Skip triggering on initial load
              if (isInitialLoad) {
                isInitialLoad = false;
                return;
              }
              triggerActiveSectionAnimation();
            }
          });
        });

        sections.forEach((section) => {
          sectionObserver.observe(section, {
            attributes: true,
            attributeFilter: ['class']
          });
        });
      } catch (error) {
        console.error('Error initializing VanillaFullpage:', error);
        return;
      }

      // Xử lý hash URL khi trang load với hash (ví dụ: #lien-he)
      const hash = window.location.hash.replace('#', '');
      if (hash) {
        const index = anchors.indexOf(hash);
        if (index !== -1 && window.vanillaFullpage) {
          // Đợi một chút để đảm bảo fullpage đã khởi tạo xong
          setTimeout(() => {
            window.vanillaFullpage.goToSection(index);
            updateSidebarActive(hash);
          }, 100);
        }
      } else {
        // Set home as active by default
        updateSidebarActive('home');
      }
    }

    // Function to update sidebar active state (both fixed and mobile)
    function updateSidebarActive(activeAnchor) {
      if (!activeAnchor || !anchors.includes(activeAnchor)) {
        return;
      }
      
      // Update both desktop (.sidebar-nav) and mobile (.sidebar-nav-mobile) sidebars
      const allSidebarLists = document.querySelectorAll('.sidebar-list');
      
      allSidebarLists.forEach((sidebarList) => {
        const sidebarItems = sidebarList.querySelectorAll('li');
        sidebarItems.forEach((item) => {
          item.classList.remove('active');
          if (item.getAttribute('data-menuanchor') === activeAnchor) {
            item.classList.add('active');
          }
        });
      });
    }

    // Initialize fade-in animations using Intersection Observer
    function initSlideInAnimations() {
      // Check if user prefers reduced motion
      const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      
      if (prefersReducedMotion) {
        // Skip animations for users who prefer reduced motion
        const slideElements = document.querySelectorAll('[data-slide-in]');
        const fadeItems = document.querySelectorAll('.fade-in-item');
        slideElements.forEach(el => el.classList.add('slide-in-visible'));
        fadeItems.forEach(el => el.classList.add('fade-in-visible'));
        return;
      }

      // Animate sections with data-slide-in - only when they enter viewport
      const slideElements = document.querySelectorAll('[data-slide-in]');
      
      if (slideElements.length > 0) {
        // Track which elements have been seen to avoid triggering on initial load
        const seenElements = new Set();
        
        const sectionObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > 0.1) {
              // Only trigger if element wasn't visible on initial load
              if (!seenElements.has(entry.target)) {
                seenElements.add(entry.target);
                // Small delay to ensure it's a real scroll/view action
                setTimeout(() => {
                  if (entry.isIntersecting) {
                    entry.target.classList.add('slide-in-visible');
                  }
                }, 50);
                sectionObserver.unobserve(entry.target);
              }
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px'
        });
        
        // Mark elements that are already visible on initial load
        slideElements.forEach(el => {
          const rect = el.getBoundingClientRect();
          const isInitiallyVisible = rect.top >= 0 && rect.top < window.innerHeight;
          if (isInitiallyVisible) {
            seenElements.add(el);
          }
        });
        
        // Observe all sections - animation will trigger when they enter viewport
        slideElements.forEach(el => {
          if (!el.classList.contains('slide-in-visible')) {
            sectionObserver.observe(el);
          }
        });
      }

      // Animate project cards and other fade-in items with stagger
      // Only trigger when scrolling to the section (not on initial load)
      const fadeItems = document.querySelectorAll('.fade-in-item');
      
      if (fadeItems.length > 0) {
        // Track items that were visible on initial load (to skip them)
        const initiallyVisibleItems = new Set();
        
        // Check which items are already visible on page load
        fadeItems.forEach(item => {
          const rect = item.getBoundingClientRect();
          const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
          if (isVisible) {
            initiallyVisibleItems.add(item);
          }
        });
        
        const itemObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > 0.1) {
              const item = entry.target;
              
              // Skip items that were visible on initial load
              if (initiallyVisibleItems.has(item)) {
                itemObserver.unobserve(item);
                return;
              }
              
              // Only trigger when item enters viewport (scrolled to)
              const delay = parseInt(item.getAttribute('data-fade-delay') || '0');
              setTimeout(() => {
                item.classList.add('fade-in-visible');
              }, delay);
              itemObserver.unobserve(item);
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px'
        });
        
        // Observe all items - will only trigger when they enter viewport
        fadeItems.forEach(el => {
          if (!el.classList.contains('fade-in-visible')) {
            itemObserver.observe(el);
          }
        });
      }
    }

    // Handle window resize
    let resizeTimeout;
    function handleResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const wasMobile = document.body.classList.contains('mobile-layout');
        const nowMobile = isMobile();

        if (wasMobile && !nowMobile) {
          // Resized from mobile to desktop
          destroyMobileLayout();
          if (typeof VanillaFullpage !== 'undefined' && !window.vanillaFullpage) {
            initFullpage();
          }
        } else if (!wasMobile && nowMobile) {
          // Resized from desktop to mobile
          if (window.vanillaFullpage) {
            // Destroy fullpagejs instance if possible
            if (window.vanillaFullpage.destroy) {
              window.vanillaFullpage.destroy();
            }
            window.vanillaFullpage = null;
          }
          setupMobileLayout();
        }
      }, 150);
    }

    // Khởi tạo khi DOM ready
    function init() {
      // Check mobile first and setup immediately
      if (isMobile()) {
        setupMobileLayout();
      } else {
        // Chỉ load fullpage.js script trên desktop
        const script = document.createElement('script');
        script.src = '/js/vanilla-fullpage.js';
        script.async = true;
        script.onload = function() {
          // Wait a bit for script to fully initialize
          setTimeout(initFullpage, 100);
        };
        document.head.appendChild(script);
      }
      window.addEventListener('resize', handleResize);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      // Nếu DOM đã ready, chạy ngay
      setTimeout(init, 50);
    }
  </script>
</BaseLayout>
